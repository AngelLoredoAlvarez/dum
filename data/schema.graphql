"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""A brand of products in the Store."""
type Brand implements Node {
  """The name of the brand."""
  brand: String!
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """Reads and enables pagination through a set of `Product`."""
  products(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsConnection!

  """Unique identifier for the brands."""
  rowId: UUID!
  updatedAt: Datetime!
}

"""
A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BrandCondition {
  """Checks for equality with the object’s `brand` field."""
  brand: String

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID
}

"""A connection to a list of `Brand` values."""
type BrandsConnection {
  """
  A list of edges which contains the `Brand` and cursor to aid in pagination.
  """
  edges: [BrandsEdge!]!

  """A list of `Brand` objects."""
  nodes: [Brand!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection."""
type BrandsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Brand` at the end of the edge."""
  node: Brand!
}

"""Methods to use when ordering `Brand`."""
enum BrandsOrderBy {
  BRAND_ASC
  BRAND_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""All input for the `changePassword` mutation."""
input ChangePasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  newPassword: String!
  oldPassword: String!
}

"""The output of our `changePassword` mutation."""
type ChangePasswordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

"""All input for the `confirmAccountDeletion` mutation."""
input ConfirmAccountDeletionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
}

"""The output of our `confirmAccountDeletion` mutation."""
type ConfirmAccountDeletionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

"""All input for the create `UserEmail` mutation."""
input CreateUserEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UserEmail` to be created by this mutation."""
  userEmail: UserEmailInput!
}

"""The output of our create `UserEmail` mutation."""
type CreateUserEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserEmail`."""
  user: User

  """The `UserEmail` that was created by this mutation."""
  userEmail: UserEmail

  """An edge for our `UserEmail`. May be used by Relay 1."""
  userEmailEdge(
    """The method to use when ordering `UserEmail`."""
    orderBy: [UserEmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserEmailsEdge
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""All input for the `deleteUserAuthenticationById` mutation."""
input DeleteUserAuthenticationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserAuthentication` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUserAuthentication` mutation."""
input DeleteUserAuthenticationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `UserAuthentication` mutation."""
type DeleteUserAuthenticationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUserAuthenticationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserAuthentication`."""
  user: User

  """The `UserAuthentication` that was deleted by this mutation."""
  userAuthentication: UserAuthentication
}

"""All input for the `deleteUserEmailById` mutation."""
input DeleteUserEmailByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserEmail` to be deleted.
  """
  id: ID!
}

"""All input for the `deleteUserEmail` mutation."""
input DeleteUserEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rowId: UUID!
}

"""The output of our delete `UserEmail` mutation."""
type DeleteUserEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUserEmailId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserEmail`."""
  user: User

  """The `UserEmail` that was deleted by this mutation."""
  userEmail: UserEmail

  """An edge for our `UserEmail`. May be used by Relay 1."""
  userEmailEdge(
    """The method to use when ordering `UserEmail`."""
    orderBy: [UserEmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserEmailsEdge
}

"""All input for the `forgotPassword` mutation."""
input ForgotPasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
}

"""The output of our `forgotPassword` mutation."""
type ForgotPasswordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The `GeoJSON` scalar type represents GeoJSON values as specified by[RFC 7946](https://tools.ietf.org/html/rfc7946).
"""
scalar GeoJSON

"""All geometry XY types implement this interface"""
interface GeometryGeometry {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

"""All geometry types implement this interface"""
interface GeometryInterface {
  """Converts the object to GeoJSON"""
  geojson: GeoJSON

  """Spatial reference identifier (SRID)"""
  srid: Int!
}

type GeometryPoint implements GeometryGeometry & GeometryInterface {
  geojson: GeoJSON
  srid: Int!
  x: Float!
  y: Float!
}

input LoginInput {
  password: String!
  username: String!
}

type LoginPayload {
  user: User!
}

type LogoutPayload {
  success: Boolean
}

type Lot implements Node {
  block: Int!
  geom: GeometryPoint!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  latlong: String
  number: Int!
  rowId: UUID!
}

"""
A condition to be used against `Lot` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LotCondition {
  """Checks for equality with the object’s `geom` field."""
  geom: GeoJSON

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID
}

"""A connection to a list of `Lot` values."""
type LotsConnection {
  """
  A list of edges which contains the `Lot` and cursor to aid in pagination.
  """
  edges: [LotsEdge!]!

  """A list of `Lot` objects."""
  nodes: [Lot!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Lot` you could get from the connection."""
  totalCount: Int!
}

"""A `Lot` edge in the connection."""
type LotsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Lot` at the end of the edge."""
  node: Lot!
}

"""Methods to use when ordering `Lot`."""
enum LotsOrderBy {
  GEOM_ASC
  GEOM_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A Main Department wich the Store will have."""
type MainDepartment implements Node {
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """The name of the Main Department."""
  mainDepartment: String!
  pictureUrl: String

  """Unique identifier for the Main Department."""
  rowId: UUID!

  """Reads and enables pagination through a set of `SubDepartment`."""
  subDepartmentsByDepartmentId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubDepartmentCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SubDepartment`."""
    orderBy: [SubDepartmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubDepartmentsConnection!
  updatedAt: Datetime!
}

"""
A condition to be used against `MainDepartment` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input MainDepartmentCondition {
  """Checks for equality with the object’s `mainDepartment` field."""
  mainDepartment: String

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID
}

"""A connection to a list of `MainDepartment` values."""
type MainDepartmentsConnection {
  """
  A list of edges which contains the `MainDepartment` and cursor to aid in pagination.
  """
  edges: [MainDepartmentsEdge!]!

  """A list of `MainDepartment` objects."""
  nodes: [MainDepartment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MainDepartment` you could get from the connection."""
  totalCount: Int!
}

"""A `MainDepartment` edge in the connection."""
type MainDepartmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MainDepartment` at the end of the edge."""
  node: MainDepartment!
}

"""Methods to use when ordering `MainDepartment`."""
enum MainDepartmentsOrderBy {
  ID_ASC
  ID_DESC
  MAIN_DEPARTMENT_ASC
  MAIN_DEPARTMENT_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""All input for the `makeEmailPrimary` mutation."""
input MakeEmailPrimaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  emailId: UUID!
}

"""The output of our `makeEmailPrimary` mutation."""
type MakeEmailPrimaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserEmail`."""
  user: User
  userEmail: UserEmail

  """An edge for our `UserEmail`. May be used by Relay 1."""
  userEmailEdge(
    """The method to use when ordering `UserEmail`."""
    orderBy: [UserEmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserEmailsEdge
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Enter your old password and a new password to change your password."""
  changePassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ChangePasswordInput!
  ): ChangePasswordPayload

  """
  If you're certain you want to delete your account, use `requestAccountDeletion` to request an account deletion token, and then supply the token through this mutation to complete account deletion.
  """
  confirmAccountDeletion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ConfirmAccountDeletionInput!
  ): ConfirmAccountDeletionPayload

  """Creates a single `UserEmail`."""
  createUserEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserEmailInput!
  ): CreateUserEmailPayload

  """Deletes a single `UserAuthentication` using a unique key."""
  deleteUserAuthentication(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAuthenticationInput!
  ): DeleteUserAuthenticationPayload

  """Deletes a single `UserAuthentication` using its globally unique id."""
  deleteUserAuthenticationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserAuthenticationByIdInput!
  ): DeleteUserAuthenticationPayload

  """Deletes a single `UserEmail` using a unique key."""
  deleteUserEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserEmailInput!
  ): DeleteUserEmailPayload

  """Deletes a single `UserEmail` using its globally unique id."""
  deleteUserEmailById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserEmailByIdInput!
  ): DeleteUserEmailPayload

  """
  If you've forgotten your password, give us one of your email addresses and we'll send you a reset token. Note this only works if you have added an email address!
  """
  forgotPassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ForgotPasswordInput!
  ): ForgotPasswordPayload

  """
  Use this mutation to log in to your account; this login uses sessions so you do not need to take further action.
  """
  login(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LoginInput!
  ): LoginPayload

  """
  Use this mutation to logout from your account. Don't forget to clear the client state!
  """
  logout: LogoutPayload

  """
  Your primary email is where we'll notify of account events; other emails may be used for discovery or login. Use this when you're changing your email address.
  """
  makeEmailPrimary(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MakeEmailPrimaryInput!
  ): MakeEmailPrimaryPayload

  """
  Use this mutation to create an account on our system. This may only be used if you are logged out.
  """
  register(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterInput!
  ): RegisterPayload

  """Begin the account deletion flow by requesting the confirmation email"""
  requestAccountDeletion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RequestAccountDeletionInput!
  ): RequestAccountDeletionPayload

  """
  If you didn't receive the verification code for this email, we can resend it. We silently cap the rate of resends on the backend, so calls to this function may not result in another email being sent if it has been called recently.
  """
  resendEmailVerificationCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResendEmailVerificationCodeInput!
  ): ResendEmailVerificationCodePayload

  """
  After triggering forgotPassword, you'll be sent a reset token. Combine this with your user ID and a new password to reset your password.
  """
  resetPassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResetPasswordInput!
  ): ResetPasswordPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """
  Once you have received a verification token for your email, you may call this mutation with that token to make your email verified.
  """
  verifyEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: VerifyEmailInput!
  ): VerifyEmailPayload
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
}

"""A post of interest for the user."""
type Post implements Node {
  age: String

  """The topic of the post."""
  body: String
  createdAt: Datetime!
  date: String
  fullDate: String

  """The headline or title of the post."""
  headline: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """Unique identifier for the post."""
  rowId: UUID!
  time: String
  topic: PostTopic
  updatedAt: Datetime!
}

enum PostTopic {
  NEWS
}

"""A connection to a list of `Post` values."""
type PostsConnection {
  """
  A list of edges which contains the `Post` and cursor to aid in pagination.
  """
  edges: [PostsEdge!]!

  """A list of `Post` objects."""
  nodes: [Post!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Post` you could get from the connection."""
  totalCount: Int!
}

"""A `Post` edge in the connection."""
type PostsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Post` at the end of the edge."""
  node: Post!
}

"""A product sold in the store."""
type Product implements Node {
  """Unique code used to get the information from a product."""
  barcode: String!

  """Reads a single `Brand` that is related to this `Product`."""
  brand: Brand

  """The identifier of the Brand to wich the product belongs."""
  brandId: UUID!
  createdAt: Datetime!

  """The description of the characteristics of a product."""
  description: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  price: String

  """Reads and enables pagination through a set of `ProductPicture`."""
  productPictures(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductPictureCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ProductPicture`."""
    orderBy: [ProductPicturesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductPicturesConnection!

  """Unique identifier for the product."""
  rowId: UUID!

  """The current quantity of the product in stock."""
  stock: Int!

  """Reads a single `SubDepartment` that is related to this `Product`."""
  subDepartment: SubDepartment
  subDepartmentId: UUID!

  """The tax that applies to the product."""
  tax: BigFloat

  """The price of the product."""
  unformatedPrice: BigFloat!
  updatedAt: Datetime!
}

"""
A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProductCondition {
  """Checks for equality with the object’s `brandId` field."""
  brandId: UUID

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `subDepartmentId` field."""
  subDepartmentId: UUID
}

"""A Picture associated to a specific Product."""
type ProductPicture implements Node {
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """The Picture URL."""
  pictureUrl: String

  """Reads a single `Product` that is related to this `ProductPicture`."""
  product: Product
  productId: UUID!
  rowId: UUID!
  updatedAt: Datetime!
}

"""
A condition to be used against `ProductPicture` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ProductPictureCondition {
  """Checks for equality with the object’s `pictureUrl` field."""
  pictureUrl: String

  """Checks for equality with the object’s `productId` field."""
  productId: UUID

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID
}

"""A connection to a list of `ProductPicture` values."""
type ProductPicturesConnection {
  """
  A list of edges which contains the `ProductPicture` and cursor to aid in pagination.
  """
  edges: [ProductPicturesEdge!]!

  """A list of `ProductPicture` objects."""
  nodes: [ProductPicture!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProductPicture` you could get from the connection."""
  totalCount: Int!
}

"""A `ProductPicture` edge in the connection."""
type ProductPicturesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProductPicture` at the end of the edge."""
  node: ProductPicture!
}

"""Methods to use when ordering `ProductPicture`."""
enum ProductPicturesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PICTURE_URL_ASC
  PICTURE_URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRODUCT_ID_ASC
  PRODUCT_ID_DESC
}

"""A connection to a list of `Product` values."""
type ProductsConnection {
  """
  A list of edges which contains the `Product` and cursor to aid in pagination.
  """
  edges: [ProductsEdge!]!

  """A list of `Product` objects."""
  nodes: [Product!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection."""
type ProductsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Product` at the end of the edge."""
  node: Product!
}

"""Methods to use when ordering `Product`."""
enum ProductsOrderBy {
  BRAND_ID_ASC
  BRAND_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SUB_DEPARTMENT_ID_ASC
  SUB_DEPARTMENT_ID_DESC
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  brandByBrand(brand: String!): Brand

  """Reads a single `Brand` using its globally unique `ID`."""
  brandById(
    """The globally unique `ID` to be used in selecting a single `Brand`."""
    id: ID!
  ): Brand

  """Reads and enables pagination through a set of `Brand`."""
  brands(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BrandCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsConnection

  """The currently logged in user (or null if not logged in)."""
  currentUser: User

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  id: ID!
  lot(rowId: UUID!): Lot

  """Reads a single `Lot` using its globally unique `ID`."""
  lotById(
    """The globally unique `ID` to be used in selecting a single `Lot`."""
    id: ID!
  ): Lot

  """Reads and enables pagination through a set of `Lot`."""
  lots(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LotCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Lot`."""
    orderBy: [LotsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LotsConnection

  """Reads a single `MainDepartment` using its globally unique `ID`."""
  mainDepartmentById(
    """
    The globally unique `ID` to be used in selecting a single `MainDepartment`.
    """
    id: ID!
  ): MainDepartment
  mainDepartmentByName(arg0: String!): MainDepartment

  """Reads and enables pagination through a set of `MainDepartment`."""
  mainDepartments(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MainDepartmentCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `MainDepartment`."""
    orderBy: [MainDepartmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MainDepartmentsConnection

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    id: ID!
  ): Node
  post(rowId: UUID!): Post

  """Reads a single `Post` using its globally unique `ID`."""
  postById(
    """The globally unique `ID` to be used in selecting a single `Post`."""
    id: ID!
  ): Post

  """Reads and enables pagination through a set of `Post`."""
  posts(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): PostsConnection
  product(rowId: UUID!): Product

  """Reads a single `Product` using its globally unique `ID`."""
  productById(
    """The globally unique `ID` to be used in selecting a single `Product`."""
    id: ID!
  ): Product
  productPicture(pictureId: UUID, productId: UUID!): ProductPicture

  """Reads a single `ProductPicture` using its globally unique `ID`."""
  productPictureById(
    """
    The globally unique `ID` to be used in selecting a single `ProductPicture`.
    """
    id: ID!
  ): ProductPicture

  """Reads and enables pagination through a set of `Product`."""
  products(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsConnection
  sale(rowId: UUID!): Sale

  """Reads a single `Sale` using its globally unique `ID`."""
  saleById(
    """The globally unique `ID` to be used in selecting a single `Sale`."""
    id: ID!
  ): Sale
  shoppingList(rowId: UUID!): ShoppingList

  """Reads a single `ShoppingList` using its globally unique `ID`."""
  shoppingListById(
    """
    The globally unique `ID` to be used in selecting a single `ShoppingList`.
    """
    id: ID!
  ): ShoppingList

  """Reads a single `SubDepartment` using its globally unique `ID`."""
  subDepartmentById(
    """
    The globally unique `ID` to be used in selecting a single `SubDepartment`.
    """
    id: ID!
  ): SubDepartment
  subDepartmentByName(arg0: String!): SubDepartment

  """Reads and enables pagination through a set of `SubDepartment`."""
  subDepartments(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubDepartmentCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SubDepartment`."""
    orderBy: [SubDepartmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubDepartmentsConnection
  user(rowId: UUID!): User
  userAuthentication(rowId: UUID!): UserAuthentication

  """Reads a single `UserAuthentication` using its globally unique `ID`."""
  userAuthenticationById(
    """
    The globally unique `ID` to be used in selecting a single `UserAuthentication`.
    """
    id: ID!
  ): UserAuthentication

  """Reads a single `User` using its globally unique `ID`."""
  userById(
    """The globally unique `ID` to be used in selecting a single `User`."""
    id: ID!
  ): User
  userByUsername(username: String!): User
  userEmail(rowId: UUID!): UserEmail

  """Reads a single `UserEmail` using its globally unique `ID`."""
  userEmailById(
    """The globally unique `ID` to be used in selecting a single `UserEmail`."""
    id: ID!
  ): UserEmail
}

input RegisterInput {
  avatarUrl: String
  email: String!
  firstSurname: String!
  name: String!
  password: String!
  secondSurname: String
  username: String!
}

type RegisterPayload {
  user: User!
}

"""All input for the `requestAccountDeletion` mutation."""
input RequestAccountDeletionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `requestAccountDeletion` mutation."""
type RequestAccountDeletionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

"""All input for the `resendEmailVerificationCode` mutation."""
input ResendEmailVerificationCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  emailId: UUID!
}

"""The output of our `resendEmailVerificationCode` mutation."""
type ResendEmailVerificationCodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

"""All input for the `resetPassword` mutation."""
input ResetPasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  newPassword: String!
  resetToken: String!
  userId: UUID!
}

"""The output of our `resetPassword` mutation."""
type ResetPasswordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}

"""A sale associated to a user"""
type Sale implements Node {
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """A unique identifier for a sale."""
  rowId: UUID!

  """Reads and enables pagination through a set of `SaleDetail`."""
  saleDetails(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SaleDetailCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SaleDetail`."""
    orderBy: [SaleDetailsOrderBy!] = [NATURAL]
  ): SaleDetailsConnection!
  total: String

  """The total cost of the sale."""
  unformatedTotal: BigFloat!

  """Reads a single `User` that is related to this `Sale`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `Sale` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SaleCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""The details of a specific sale"""
type SaleDetail {
  cost: String
  productId: UUID!

  """The quantity of a specific product."""
  quantity: Int

  """Reads a single `Sale` that is related to this `SaleDetail`."""
  sale: Sale
  saleId: UUID!

  """The cost of the quantity of products."""
  unformatedCost: BigFloat!
}

"""
A condition to be used against `SaleDetail` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SaleDetailCondition {
  """Checks for equality with the object’s `saleId` field."""
  saleId: UUID
}

"""A connection to a list of `SaleDetail` values."""
type SaleDetailsConnection {
  """
  A list of edges which contains the `SaleDetail` and cursor to aid in pagination.
  """
  edges: [SaleDetailsEdge!]!

  """A list of `SaleDetail` objects."""
  nodes: [SaleDetail!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SaleDetail` you could get from the connection."""
  totalCount: Int!
}

"""A `SaleDetail` edge in the connection."""
type SaleDetailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SaleDetail` at the end of the edge."""
  node: SaleDetail!
}

"""Methods to use when ordering `SaleDetail`."""
enum SaleDetailsOrderBy {
  NATURAL
  SALE_ID_ASC
  SALE_ID_DESC
}

"""A connection to a list of `Sale` values."""
type SalesConnection {
  """
  A list of edges which contains the `Sale` and cursor to aid in pagination.
  """
  edges: [SalesEdge!]!

  """A list of `Sale` objects."""
  nodes: [Sale!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Sale` you could get from the connection."""
  totalCount: Int!
}

"""A `Sale` edge in the connection."""
type SalesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Sale` at the end of the edge."""
  node: Sale!
}

"""Methods to use when ordering `Sale`."""
enum SalesOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""A Shopping List own by a User."""
type ShoppingList implements Node {
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """
  The state of the Shopping List, true if is already sold or false if not.
  """
  isSold: Boolean

  """Unique identifier for the Shopping List."""
  rowId: UUID!

  """Reads and enables pagination through a set of `ShoppingListDetail`."""
  shoppingListDetails(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ShoppingListDetailCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ShoppingListDetail`."""
    orderBy: [ShoppingListDetailsOrderBy!] = [NATURAL]
  ): ShoppingListDetailsConnection!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `ShoppingList`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `ShoppingList` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ShoppingListCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""The details of a specific Shopping List."""
type ShoppingListDetail {
  cost: String
  productId: UUID!

  """The quantity of a specific product."""
  quantity: Int

  """
  Reads a single `ShoppingList` that is related to this `ShoppingListDetail`.
  """
  shoppingList: ShoppingList
  shoppingListId: UUID!

  """The cost of the quantity of products."""
  unformatedCost: BigFloat!
}

"""
A condition to be used against `ShoppingListDetail` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ShoppingListDetailCondition {
  """Checks for equality with the object’s `shoppingListId` field."""
  shoppingListId: UUID
}

"""A connection to a list of `ShoppingListDetail` values."""
type ShoppingListDetailsConnection {
  """
  A list of edges which contains the `ShoppingListDetail` and cursor to aid in pagination.
  """
  edges: [ShoppingListDetailsEdge!]!

  """A list of `ShoppingListDetail` objects."""
  nodes: [ShoppingListDetail!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ShoppingListDetail` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ShoppingListDetail` edge in the connection."""
type ShoppingListDetailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ShoppingListDetail` at the end of the edge."""
  node: ShoppingListDetail!
}

"""Methods to use when ordering `ShoppingListDetail`."""
enum ShoppingListDetailsOrderBy {
  NATURAL
  SHOPPING_LIST_ID_ASC
  SHOPPING_LIST_ID_DESC
}

"""A connection to a list of `ShoppingList` values."""
type ShoppingListsConnection {
  """
  A list of edges which contains the `ShoppingList` and cursor to aid in pagination.
  """
  edges: [ShoppingListsEdge!]!

  """A list of `ShoppingList` objects."""
  nodes: [ShoppingList!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ShoppingList` you could get from the connection."""
  totalCount: Int!
}

"""A `ShoppingList` edge in the connection."""
type ShoppingListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ShoppingList` at the end of the edge."""
  node: ShoppingList!
}

"""Methods to use when ordering `ShoppingList`."""
enum ShoppingListsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""A Sub - Department that belongs to a Main Department."""
type SubDepartment implements Node {
  createdAt: Datetime!

  """
  Reads a single `MainDepartment` that is related to this `SubDepartment`.
  """
  department: MainDepartment
  departmentId: UUID!
  description: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  pictureUrl: String

  """Reads and enables pagination through a set of `Product`."""
  products(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsConnection!

  """Unique identifier for the Sub - Department."""
  rowId: UUID!

  """The name of the Sub - Department."""
  subDepartment: String!
  updatedAt: Datetime!
}

"""
A condition to be used against `SubDepartment` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SubDepartmentCondition {
  """Checks for equality with the object’s `departmentId` field."""
  departmentId: UUID

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `subDepartment` field."""
  subDepartment: String
}

"""A connection to a list of `SubDepartment` values."""
type SubDepartmentsConnection {
  """
  A list of edges which contains the `SubDepartment` and cursor to aid in pagination.
  """
  edges: [SubDepartmentsEdge!]!

  """A list of `SubDepartment` objects."""
  nodes: [SubDepartment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SubDepartment` you could get from the connection."""
  totalCount: Int!
}

"""A `SubDepartment` edge in the connection."""
type SubDepartmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SubDepartment` at the end of the edge."""
  node: SubDepartment!
}

"""Methods to use when ordering `SubDepartment`."""
enum SubDepartmentsOrderBy {
  DEPARTMENT_ID_ASC
  DEPARTMENT_ID_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SUB_DEPARTMENT_ASC
  SUB_DEPARTMENT_DESC
}

"""
The root subscription type: contains realtime events you can subscribe to with the `subscription` operation.
"""
type Subscription {
  """Triggered when the logged in user's record is updated in some way."""
  currentUserUpdated: UserSubscriptionPayload
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  id: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!

  """Unique identifier for the user."""
  rowId: UUID!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `User` that was updated by this mutation."""
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""A user who can log in to the application."""
type User implements Node {
  """Optional avatar URL."""
  avatarUrl: String
  createdAt: Datetime!
  firstSurname: String
  fullName: String
  hasPassword: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """If true, the user has elevated privileges."""
  isAdmin: Boolean!
  isVerified: Boolean!

  """Public-facing name (or pseudonym) of the user."""
  name: String

  """Unique identifier for the user."""
  rowId: UUID!

  """Reads and enables pagination through a set of `Sale`."""
  sales(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SaleCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Sale`."""
    orderBy: [SalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SalesConnection!
  secondSurname: String

  """Reads and enables pagination through a set of `ShoppingList`."""
  shoppingLists(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ShoppingListCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ShoppingList`."""
    orderBy: [ShoppingListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShoppingListsConnection!
  updatedAt: Datetime!

  """Reads and enables pagination through a set of `UserAuthentication`."""
  userAuthenticationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserAuthenticationCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `UserAuthentication`."""
    orderBy: [UserAuthenticationsOrderBy!]
  ): [UserAuthentication!]!

  """Reads and enables pagination through a set of `UserEmail`."""
  userEmails(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserEmailCondition

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `UserEmail`."""
    orderBy: [UserEmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserEmailsConnection!

  """Public-facing username (or 'handle') of the user."""
  username: String!
}

"""
Contains information about the login providers this user has used, so that they may disconnect them should they wish.
"""
type UserAuthentication implements Node {
  createdAt: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!

  """A unique identifier for the user within the login service."""
  identifier: String!
  rowId: UUID!

  """The login service used, e.g. `twitter` or `github`."""
  service: String!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `UserAuthentication`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `UserAuthentication` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UserAuthenticationCondition {
  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `service` field."""
  service: String

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""Methods to use when ordering `UserAuthentication`."""
enum UserAuthenticationsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SERVICE_ASC
  SERVICE_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""Information about a user's email address."""
type UserEmail implements Node {
  createdAt: Datetime!

  """The users email address, in `a@b.c` format."""
  email: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  id: ID!
  isPrimary: Boolean!

  """
  True if the user has is_verified their email address (by clicking the link in the email we sent them, or logging in with a social login provider), false otherwise.
  """
  isVerified: Boolean!
  rowId: UUID!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `UserEmail`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `UserEmail` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UserEmailCondition {
  """Checks for equality with the object’s `isPrimary` field."""
  isPrimary: Boolean

  """Checks for equality with the object’s `rowId` field."""
  rowId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""An input for mutations affecting `UserEmail`"""
input UserEmailInput {
  """The users email address, in `a@b.c` format."""
  email: String!
}

"""A connection to a list of `UserEmail` values."""
type UserEmailsConnection {
  """
  A list of edges which contains the `UserEmail` and cursor to aid in pagination.
  """
  edges: [UserEmailsEdge!]!

  """A list of `UserEmail` objects."""
  nodes: [UserEmail!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UserEmail` you could get from the connection."""
  totalCount: Int!
}

"""A `UserEmail` edge in the connection."""
type UserEmailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserEmail` at the end of the edge."""
  node: UserEmail!
}

"""Methods to use when ordering `UserEmail`."""
enum UserEmailsOrderBy {
  ID_ASC
  ID_DESC
  IS_PRIMARY_ASC
  IS_PRIMARY_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  """Optional avatar URL."""
  avatarUrl: String

  """Public-facing name (or pseudonym) of the user."""
  name: String

  """Public-facing username (or 'handle') of the user."""
  username: String
}

type UserSubscriptionPayload {
  event: String
  user: User
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USERNAME_ASC
  USERNAME_DESC
}

"""All input for the `verifyEmail` mutation."""
input VerifyEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
  userEmailId: UUID!
}

"""The output of our `verifyEmail` mutation."""
type VerifyEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  success: Boolean
}
